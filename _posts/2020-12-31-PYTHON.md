---
layout:     post
title:      python-summary
subtitle:   summary
date:       2019-11-4
author:     RJ
header-img: 
catalog: true
tags:
    - Python

---
<p id = "build"></p>
---


## 基础数据类型的常用操作

### dict
m_dict = default_dict() 
dict2 = m_dict.update(dict1)

```python
with open('vocab/han_vocab.json', "r", encoding='utf-8') as f:
    han_dict_w2id = json.load(f)
    han_dict_w2id = defaultdict_from_dict(han_dict_w2id)
han_dict_id2w = {v: k for k, v in han_dict_w2id.items()}
```

### list
[func(x) for x in list]

' '.join(list)



### str
upper()  ：将字符串转成大写，并返回一个拷贝

lower()  ：将字符串转成小写，并返回一个拷贝

capitalize() ：将字符串首字母大写，并返回一个拷贝

title() ：将每个单词的首字母大写，并返回一个拷贝

isupper() ：判断一个字符串是否是大写

islower() ：判断一个字符串是否是小写


### Python 在递归函数中传参问题

在 Python 的递归函数中传参的时候，企图传引用遇到的问题。

最近在写 Python 的递归函数的时候遇到一个问题，企图传一个引用型参数作为计数器，失败了。

以经典的递归函数的例子来说明。
最初的写法:
```
def func(n, count):
    count += 1
    if n == 1:
        return 1
    return n * func(n-1, count)

count = 0
n = 5
res = func(n, count)
print('function result is:' + str(res))
print('counter is:' + str(count))
```
对于这个函数，我期望的 count 的值是 5，然而实际的结果是:

function result is:120
counter is:0
这里涉及到 Python 的传参机制的问题：

Python 不允许程序员选择采用传值还是传引用。Python 参数传递采用的肯定是“传对象引用”的方式。 这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值’来传递对象。

因此，有两种修改方法。其一，是把 count 变成一个可变对象，例如：
```
def func(n, count):
    count[0] += 1
    if n == 1:
        return 1
    return n * func(n-1, count)

count = [0]
n = 5
res = func(n, count)
print('function result is:' + str(res))
print('counter is:' + str(count[0]))
运行结果为：

function result is:120
counter is:5
```
不过强行把整型变量变成列表，也挺奇怪的。更正常的改法是把 count 作为返回值返回，这样：
```
def func(n, count):
    count += 1
    if n == 1:
        return 1, count
    tmp_n, count = func(n-1, count)
    return n * tmp_n, count

count = 0
n = 5
res, count = func(n, count)
print('function result is:' + str(res))
print('counter is:' + str(count))
运行结果为：

function result is:120
counter is:5
```

## random
```python

#1.使用python random模块的choice方法随机选择某个元素
import random
foo = ['a', 'b', 'c', 'd', 'e']
from random import choice
print choice(foo)
 
#2.使用python random模块的sample函数从列表中随机选择一组元素
list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
#设置种子使得每次抽样结果相同
random.seed(10)
slice = random.sample(list, 5)  #从list中随机获取5个元素，作为一个片断返回  
print slice  
print list #原有序列并没有改变。
```

## pandas 

修改列名 & 行名：

```python
df.rename(columns={'two':'twotwo'},inplace=True)
print(df)


df.rename(index={'a':'aa','b':'bb'},inplace=True)
print(df)
```

将test.csv中部分columns抽取出来，结合其他的csv文件中的部分信息，重构成一个新的df:

```python
df=pd.read_csv('test.csv')
df['0']=0 # 新增三列
df['1']=0
df['2']=0
for i in range(k):
    temp=pd.read_csv('{}{}/sub.csv'.format(args.model_prefix,i))
    df['0']+=temp['label_0']/k
    df['1']+=temp['label_1']/k
    df['2']+=temp['label_2']/k
```


### pandas df 提取
```python
import numpy as np
from pandas import DataFrame
import pandas as pd


df=DataFrame(np.arange(12).reshape((3,4)),index=['one','two','thr'],columns=list('abcd'))

df['a']#取a列
df[['a','b']]#取a、b列

#ix可以用数字索引，也可以用index和column索引
df.ix[0]#取第0行
df.ix[0:1]#取第0行
df.ix['one':'two']#取one、two行
df.ix[0:2,0]#取第0、1行，第0列
df.ix[0:1,'a']#取第0行，a列
df.ix[0:2,'a':'c']#取第0、1行，abc列
df.ix['one':'two','a':'c']#取one、two行，abc列
df.ix[0:2,0:1]#取第0、1行，第0列
df.ix[0:2,0:2]#取第0、1行，第0、1列

#loc只能通过index和columns来取，不能用数字
df.loc['one','a']#one行，a列
df.loc['one':'two','a']#one到two行，a列
df.loc['one':'two','a':'c']#one到two行，a到c列
df.loc['one':'two',['a','c']]#one到two行，ac列

#iloc只能用数字索引，不能用索引名
df.iloc[0:2]#前2行
df.iloc[0]#第0行
df.iloc[0:2,0:2]#0、1行，0、1列
df.iloc[[0,2],[1,2,3]]#第0、2行，1、2、3列

#iat取某个单值,只能数字索引
df.iat[1,1]#第1行，1列
#at取某个单值,只能index和columns索引
df.at['one','a']#one行，a列
```

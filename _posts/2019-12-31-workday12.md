---
layout:     post
title:      workday12
subtitle:   
date:       2019-12-31
author:     RJ
header-img: 
catalog: true
tags:
    - Job


---
<p id = "build"></p>
---



## 指定GPU训练

with tf.device('/gpu:2'):

import os

os.environ['CUDA_VISIBLE_DEVICES']='2'

os.environ['CUDA_VISIBLE_DEVICES']='2,3'

CUDA_VISIBLE_DEVICES=2 python train.py



## 清洗语料为统一格式，进行训练：

![](https://raw.githubusercontent.com/rejae/rejae.github.io/master/img/20191231dataclear1.png)

将各个txt文件，按格式汇总到train.tsv文件中，取train.tsv以外的ai_shell_test.txt文件为Test数据。

train.tsv共计1,106,100条数据，大小为150M

ai_shell_test.txt数据共7176条数据，大小为1.2M

## baseline训练
在保持 warm_up启动，gelu激活，batch_size=16 的情况下：

此次训练进行FFNN的对比实验，查看在每个block中使用FFNN和仅最后一个使用FFNN的效果。




## 4.研究decoder部分
一般的，encoder进行特征抽取和编码后，接一个全连接映射到label大小的空间上，再用softmax放缩一下结果就得到了预测label.

我对decoder不太熟悉，今天特此学习一下。
```python
    def decode(self, ys, memory, src_masks, training=True):
        '''
        memory: encoder outputs. (N, T1, d_model)
        src_masks: (N, T1)

        Returns
        logits: (N, T2, V). float32.
        y_hat: (N, T2). int32
        y: (N, T2). int32
        sents2: (N,). string.
        '''
        with tf.variable_scope("decoder", reuse=tf.AUTO_REUSE):
            decoder_inputs, y, seqlens, sents2 = ys

            # tgt_masks
            tgt_masks = tf.math.equal(decoder_inputs, 0)  # (N, T2)

            # embedding
            dec = tf.nn.embedding_lookup(self.embeddings, decoder_inputs)  # (N, T2, d_model)
            dec *= self.hp.d_model ** 0.5  # scale

            dec += positional_encoding(dec, self.hp.maxlen2)
            dec = tf.layers.dropout(dec, self.hp.dropout_rate, training=training)

            # Blocks
            for i in range(self.hp.num_blocks):
                with tf.variable_scope("num_blocks_{}".format(i), reuse=tf.AUTO_REUSE):
                    # Masked self-attention (Note that causality is True at this time)
                    dec = multihead_attention(queries=dec,
                                              keys=dec,
                                              values=dec,
                                              key_masks=tgt_masks,
                                              num_heads=self.hp.num_heads,
                                              dropout_rate=self.hp.dropout_rate,
                                              training=training,
                                              causality=True,
                                              scope="self_attention")

                    # Vanilla attention
                    dec = multihead_attention(queries=dec,
                                              keys=memory,
                                              values=memory,
                                              key_masks=src_masks,
                                              num_heads=self.hp.num_heads,
                                              dropout_rate=self.hp.dropout_rate,
                                              training=training,
                                              causality=False,
                                              scope="vanilla_attention")
                    ### Feed Forward
                    dec = ff(dec, num_units=[self.hp.d_ff, self.hp.d_model])

        # Final linear projection (embedding weights are shared)
        weights = tf.transpose(self.embeddings) # (d_model, vocab_size)
        logits = tf.einsum('ntd,dk->ntk', dec, weights) # (N, T2, vocab_size)
        y_hat = tf.to_int32(tf.argmax(logits, axis=-1))

        return logits, y_hat, y, sents2
```
